<!DOCTYPE html>
<html>
<head>
    <title>Next Bus Times</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .stop-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .stop-section h2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            width: 100%;
        }
        .line-section {
            border-left: 4px solid #2c3e50;
            padding: 10px;
            margin: 10px 0;
        }
        .bus-time {
            background-color: #f8f9fa;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .line-number {
            display: inline-block;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }
        .time {
            float: right;
            color: #27ae60;
        }
        h1, h2 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
        }
        .error {
            color: #e74c3c;
            padding: 10px;
            background-color: #fadbd8;
            border-radius: 4px;
        }
        .service-messages {
            margin: 20px 0;
        }
        
        .primary-messages {
            margin: 20px 0;
            border-left: 4px solid #856404;
        }
        
        .secondary-messages {
            margin: 20px 0;
            border-left: 4px solid #6c757d;
        }
        
        .message {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .message.secondary {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            color: #6c757d;
            opacity: 0.8;
        }
        
        .message:before {
            content: "⚠️ ";
        }
        
        .message.secondary:before {
            content: "ℹ️ ";
        }
        
        .affected-stops {
            font-size: 0.9em;
            margin-top: 8px;
            color: #666;
        }
        
        .error-section {
            margin: 20px 0;
        }
        
        .error-message {
            margin: 10px 0;
            padding: 10px;
            background-color: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
        }
        
        .error-message:before {
            content: "❌ ";
        }
        
        .stop-error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .debug-section {
            margin: 10px 0;
            font-family: monospace;
        }
        
        .debug-button {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .debug-content {
            display: none;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            white-space: pre-wrap;
            overflow-x: auto;
            margin-top: 5px;
        }
        
        .debug-content.show {
            display: block;
        }
        
        #map {
            height: 400px;
            margin: 20px 0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .line-color-56 { color: #1e88e5; }
        .line-color-59 { color: #43a047; }
        
        .leaflet-popup-content {
            margin: 8px;
            font-size: 14px;
        }
        /* Add these styles */
.leaflet-popup-content {
    min-width: 200px;
}

.leaflet-popup-content .line-info {
    margin: 4px 0;
    display: flex;
    align-items: center;
}

.leaflet-popup-content .arrival-times {
    margin-left: 38px;  /* line number width + margin */
    color: #666;
    font-size: 0.9em;
    margin-bottom: 8px;
}

.leaflet-popup-content .delijn-line-number,
.leaflet-popup-content .line-number {
    margin-right: 8px;
    min-width: 30px;
    text-align: center;
}
        
        .debug-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .affected-details {
            margin-top: 8px;
            font-size: 0.9em;
        }
        
        .affected-lines {
            margin-bottom: 4px;
        }
        
        .affected-lines .line-number {
            display: inline-block;
            padding: 2px 8px;
            margin-right: 4px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
            font-size: 0.9em;
        }
        
        .affected-stops {
            color: #666;
        }
        
        .end-service {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        
        .service-message {
            font-weight: bold;
        }
        
        .vehicle-marker {
            
            background: none;
            border: none;
        }
        
        .vehicle-marker-content {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            padding: 2px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transform: rotate(var(--bearing));
            width: 20px;
            height: 20px;
        }
        
        .line-number,
        .delijn-line-number {
            display: block;
            font-size: 11px;
            text-align: center;
            border-radius: 4px;
            padding: 1px 2px;
            min-width: 16px;
            max-width: fit-content;
            overflow: hidden;
        }
        
        .line-number {
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        .delijn-line-number {
            color: var(--text-color);
            background-color: var(--bg-color);
            border: 1px solid var(--text-border-color, transparent);
            box-shadow: 0 0 0 1px var(--bg-border-color, transparent);
        }
        
        /* For non-vehicle markers (like in popups and lists) */
        .line-info:not(.vehicle-marker-content) .line-number,
        .line-info:not(.vehicle-marker-content) .delijn-line-number {
            display: inline-block;
            padding: 2px 6px;
            min-width: 30px;
            max-width: none;
        }
        
        .vehicle-arrow {
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 5px solid currentColor;
            margin-bottom: 1px;
        }
        
        .time-display {
            white-space: nowrap;
            margin-left: 8px;
            display: inline-flex;
            align-items: baseline;
            gap: 2px;
        }
        
        .time-display.delijn {
            display: inline-flex;
            align-items: baseline;
            gap: 2px;
        }
        
        .time-display .minutes {
            margin-right: 0;
        }
        
        .time-display .actual-time {
            margin-left: 0;
        }
        
        .time-display.delijn .actual-time {
            color: #666;
            font-size: 0.9em;
            margin-left: 0;
        }
        
        .times-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: baseline;
            margin-left: auto;
            justify-content: flex-end;
        }
        
        .minutes {
            color: #27ae60;  /* Green color */
            font-weight: bold;
        }
        
        .actual-time {
            color: #666;     /* Grey color */
            font-size: 0.9em;
        }
        
        .line-container {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            padding: 4px 8px;
            min-width: 0;
        }
        
        .line-info {
            flex-shrink: 0;
            margin-right: 16px;
        }
        
        .line-number {
            
            border-radius: 4px;
            
        }
        
        .direction {
            color: #333;
        }
        
        .times-container {
            display: flex;
            align-items: center;
            margin-left: auto;  /* This will push the times to the right */
            text-align: right;
        }
        
        .time-display {
            display: inline-flex;
            align-items: center;
            margin-left: 12px;  /* Changed from margin-right to margin-left */
        }
        
        .minutes {
            color: #27ae60;  /* Default green color */
            font-weight: bold;
            margin-right: 4px;
        }
        
        .minutes.late {
            color: #e74c3c;  /* Red color for negative minutes */
        }
        
        .actual-time {
            color: #666;
            font-size: 0.9em;
        }

        .service-message {
            /* Existing styles for service messages */
            display: block;  /* This will make messages appear on their own line */
        }
        
        .loading {
            padding: 20px;
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        /* Add a subtle loading animation */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .loading {
            animation: pulse 1.5s infinite;
        }
        .stop-divider {
            margin: 15px 0;
            border-top: 1px solid #eee;
        }
        .stop-content {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .physical-stop {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stop-divider {
            margin: 15px 0;
            border-top: 1px solid #eee;
        }

        .no-data {
            text-align: center;
            color: #666;
            padding: 10px;
            font-style: italic;

        }

    /* Add styles for De Lijn specific elements */
    .delijn-line-number {
        padding: 1px 2px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: bold;
        width: 100%;
        text-align: center;
        color: var(--text-color);
        background-color: var(--bg-color);
        border: 1px solid var(--text-border-color);
        box-shadow: 0 0 0 1px var(--bg-border-color);
    }

    .delijn-line-number::after {
        content: '';
        position: absolute;
        top: -2px;
        right: -2px;
        bottom: -2px;
        left: -2px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        pointer-events: none;
    }

    .time-display.delijn {
        display: inline-flex;
        align-items: baseline;
        gap: 4px;
    }

    .time-display.delijn .scheduled-time {
        color: #666;
        font-size: 0.9em;
    }

    .time-display.delijn .realtime-time {
        font-weight: bold;
    }

    .scheduled-time {
        color: #666;
        font-size: 1em;
    }

    .realtime-indicator {
        margin-left: 4px;
        font-size: 0.9em;
        padding: 1px 4px;
        border-radius: 3px;
    }

    .realtime-indicator.early {
        color: #f1c40f;  /* Yellow for early */
    }

    .realtime-indicator.late {
        color: #e74c3c;  /* Red for late */
    }

    .realtime-indicator.on-time {
        color: #27ae60;  /* Green for on time */
    }

    /* Add styles for De Lijn line container */
    .line-container.delijn {
        margin-bottom: 10px;
    }

    .line-info.delijn {
        display: flex;
        align-items: center;
        min-width: 200px;
    }

    /* Base styles for line numbers in messages and popups */
    .affected-lines .line-number,
    .line-info:not(.vehicle-marker-content) .line-number {
        display: inline-block;
        padding: 2px 8px;
        margin-right: 8px;
        border-radius: 4px;
        color: white;
        font-weight: bold;
        min-width: 30px;
        text-align: center;
    }

    /* De Lijn line numbers in messages and popups */
    .affected-lines .delijn-line-number,
    .line-info:not(.vehicle-marker-content) .delijn-line-number {
        display: inline-block;
        padding: 2px 8px;
        margin-right: 8px;
        border-radius: 4px;
        font-weight: bold;
        min-width: 30px;
        max-width: fit-content;
        text-align: center;
        color: var(--text-color);
        background-color: var(--bg-color);
        border: 1px solid var(--text-border-color);
        box-shadow: 0 0 0 1px var(--bg-border-color);
    }

    /* Container for affected lines to ensure proper spacing */
    .affected-lines {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        margin: 8px 0;
    }

    .time-display.delijn .minutes.early {
        color: #f1c40f;  /* Yellow for early */
    }

    .time-display.delijn .minutes.late {
        color: #e74c3c;  /* Red for late */
    }

    .time-display.delijn .minutes.on-time {
        color: #27ae60;  /* Green for on time */
    }

    .realtime-indicator {
        margin-right: 4px;
    }

    .time-display.delijn .actual-time {
        color: #666;
        font-size: 0.9em;
        margin-left: 4px;
    }

    /* Add these styles */
    .leaflet-popup-content {
        min-width: 200px;
    }

    .leaflet-popup-content .line-info {
        margin: 4px 0;
        display: flex;
        align-items: center;
    }

    .leaflet-popup-content .arrival-times {
        margin-left: 38px;  /* line number width + margin */
        color: #666;
        font-size: 0.9em;
        margin-bottom: 8px;
    }

    .leaflet-popup-content .delijn-line-number,
    .leaflet-popup-content .line-number {
        margin-right: 8px;
        min-width: 30px;
        text-align: center;
    }

    .physical-stop[data-provider="delijn"] .line-number {
        padding: 1px 2px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: bold;
        width: 100%;
        text-align: center;
        color: var(--text-color);
        background-color: var(--bg-color);
        border: 1px solid var(--text-border-color);
        box-shadow: 0 0 0 1px var(--bg-border-color);
    }

    /* Add these new styles */
    .distance-info {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 10px 15px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        z-index: 1000;
        font-size: 0.9em;
        max-width: 200px;
        transition: opacity 0.3s ease;
    }

    .distance-info.loading {
        color: #666;
        font-style: italic;
    }

    .distance-info.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .walking-time {
        color: #27ae60;
        font-weight: bold;
    }

    .distance {
        color: #666;
        font-size: 0.8em;
    }

    /* Add these styles */
    .stop-distance {
        display: inline-flex;
        align-items: baseline;
        gap: 4px;
        font-size: 0.8em;
        margin-left: auto;
        color: #666;
    }

    .walking-time {
        color: #27ae60;
        font-weight: bold;
    }

    .distance {
        color: #666;
        font-size: 0.9em;
    }

    /* Add these styles */
    .map-controls {
        text-align: center;
        margin: 4px 0;
        font-size: 0.8em;
        color: #666;
        margin-top: -20px;
    }

    .map-controls a {
        color: #666;
        text-decoration: none;
        cursor: pointer;
        padding: 2px 8px;
    }

    .map-controls a:hover {
        color: #27ae60;
        text-decoration: underline;
    }
    }
    </style>
    <script>
        // Configuration from server
        const map_config = {{ map_config|tojson|safe }};
        const WALKING_SPEED = {{ walking_speed }};  // meters per second
        const LOCATION_UPDATE_INTERVAL = {{ location_update_interval }} * 1000;  // Convert to milliseconds
        const REFRESH_INTERVAL = {{ refresh_interval }} * 1000;  // Convert to milliseconds
    </script>
    <script>
    let map;
    let stopsLayer;
    let routesLayer;
    let vehiclesLayer;
    let lineColors = {{ route_colors|tojson|safe }};
    let vehicleMarkers = new Map();  // Store markers by their unique position key
    let stopNames = {};
    let delijnConfig = null;
    let DELIJN_STOP_IDS = new Set();  // Will be populated when we get delijnConfig
    let userLocation = null;
    let locationWatchId = null;
    let lastLocationUpdate = 0;
    const isSecure = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';

    // Add this function to fetch De Lijn route data
    async function fetchDeLijnRoutes(lines) {
        const routes = {};
        for (const line of lines) {
            try {
                const response = await fetch(`/api/delijn/lines/${line}/route`);
                if (response.ok) {
                    routes[line] = await response.json();
                    console.log(`Fetched De Lijn route for line ${line}:`, routes[line]);
                }
            } catch (e) {
                console.error(`Error fetching route for De Lijn line ${line}:`, e);
            }
        }
        return routes;
    }

    // Update the fetchAndUpdateData function
    async function fetchAndUpdateData() {
        try {
            console.log("Starting data fetch...");
            
            // Fetch STIB data
            const stibResponse = await fetch('/api/data');
            console.log("STIB response status:", stibResponse.status);
            
            // Fetch De Lijn data
            const delijnResponse = await fetch('/api/delijn/data');
            console.log("De Lijn response status:", delijnResponse.status);
            
            // Fetch De Lijn messages
            const delijnMessagesResponse = await fetch('/api/delijn/messages');
            console.log("De Lijn messages response status:", delijnMessagesResponse.status);
            
            // Fetch De Lijn vehicles for each monitored line
            const delijnVehiclesPromises = delijnConfig.monitored_lines.map(line => 
                fetch(`/api/delijn/vehicles/${line}`)
            );
            const delijnVehiclesResponses = await Promise.all(delijnVehiclesPromises);
            console.log("De Lijn vehicles responses:", delijnVehiclesResponses.map(r => r.status));
            
            if (stibResponse.status === 429) {
                // Handle rate limiting as before...
                return;
            }

            if (!stibResponse.ok || !delijnResponse.ok) {
                throw new Error(`HTTP error! STIB status: ${stibResponse.status}, De Lijn status: ${delijnResponse.status}`);
            }

            const stibData = await stibResponse.json();
            const delijnData = await delijnResponse.json();
            const delijnMessages = delijnMessagesResponse.ok ? await delijnMessagesResponse.json() : { messages: [] };
            const delijnVehiclesData = await Promise.all(
                delijnVehiclesResponses.map(async r => {
                    if (!r.ok) return [];
                    const data = await r.json();
                    // Handle both array and object formats
                    return Array.isArray(data) ? data : data.vehicles || [];
                })
            );
            
            console.log('STIB data:', stibData);
            console.log('De Lijn data:', delijnData);
            console.log('De Lijn messages:', delijnMessages);
            console.log('De Lijn vehicles:', delijnVehiclesData);

            // Transform De Lijn data to match STIB format
            const transformedDelijnData = {
                stops_data: {},
                messages: { messages: [] },
                processed_vehicles: [],
                errors: []
            };

            // Transform vehicle positions
            const allDelijnVehicles = delijnVehiclesData.flat();
            console.log("Processing De Lijn vehicles:", allDelijnVehicles);
            transformedDelijnData.processed_vehicles = allDelijnVehicles.map(vehicle => ({
                line: vehicle.line,
                direction: vehicle.direction,
                interpolated_position: [vehicle.position.lat, vehicle.position.lon],
                bearing: vehicle.bearing,
                is_valid: vehicle.is_valid,
                delay: vehicle.delay
            }));

            // Transform service messages
            console.log("Processing De Lijn messages:", delijnMessages);
            transformedDelijnData.messages.messages = Array.isArray(delijnMessages) ? 
                delijnMessages.map(msg => ({
                    text: msg.description || msg.title,
                    lines: msg.affected_lines,
                    stops: msg.affected_stops?.map(stop => stop.name || stop.id) || [],
                    is_monitored: msg.is_monitored,
                    priority: 1,
                    title: msg.title,
                    description: msg.description,
                    line_colors: msg.line_colors,
                    affected_lines: msg.affected_lines,
                    affected_stops: msg.affected_stops,
                    period: msg.period,
                    type: msg.type
                })) :
                // If delijnMessages is not an array, check if it has a messages property
                delijnMessages?.messages?.map(msg => ({
                    text: msg.description || msg.title,
                    lines: msg.affected_lines,
                    stops: msg.affected_stops?.map(stop => stop.name || stop.id) || [],
                    is_monitored: msg.is_monitored,
                    priority: 1,
                    title: msg.title,
                    description: msg.description,
                    line_colors: msg.line_colors,
                    affected_lines: msg.affected_lines,
                    affected_stops: msg.affected_stops,
                    period: msg.period,
                    type: msg.type
                })) || [];

            // Update line colors
            if (delijnData.colors) {
                console.log("Updating De Lijn line colors:", delijnData.colors);
                Object.entries(delijnData.colors).forEach(([line, colors]) => {
                    lineColors[line] = colors;
                });
            }

            // Combine the data
            const combinedData = {
                stops_data: {
                    ...stibData.stops_data,
                    ...transformedDelijnData.stops_data
                },
                messages: {
                    messages: [
                        ...(stibData.messages?.messages || []),
                        ...transformedDelijnData.messages.messages
                    ]
                },
                processed_vehicles: [
                    ...(stibData.processed_vehicles || []),
                    ...transformedDelijnData.processed_vehicles
                ],
                errors: [
                    ...(stibData.errors || []),
                    ...transformedDelijnData.errors
                ]
            };

            console.log("Combined data:", combinedData);

            // Update the UI with combined data
            console.log("Updating stops data...");
            updateStopsData(combinedData.stops_data);
            
            console.log("Updating service messages...");
            updateServiceMessages(combinedData.messages);
            
            console.log("Updating map data...");
            await updateMapData(combinedData);
            
            console.log("Updating errors...");
            updateErrors(combinedData.errors, []);

        } catch (error) {
            console.error('Error fetching data:', error);
            const errorsContainer = document.getElementById('errors-container');
            if (errorsContainer) {
                errorsContainer.innerHTML = `
                    <div class="error-section">
                        <div class="error-message">
                            Error fetching real-time data: ${error.message}
                        </div>
                    </div>
                `;
            }
        }
    }

    function updateStopsData(stopsData) {
        console.log("Updating stops data with:", stopsData);
        const sections = document.querySelectorAll('.stop-section');
        
        sections.forEach(section => {
            const stopName = section.dataset.stopName;
            const content = section.querySelector('.stop-content');
            const physicalStops = content.querySelectorAll('.physical-stop');
            
            physicalStops.forEach(stopContainer => {
                const stopId = stopContainer.dataset.stopId;
                // Determine provider based on stop ID
                const isDelijn = DELIJN_STOP_IDS.has(stopId);
                const provider = isDelijn ? 'delijn' : 'stib';
                stopContainer.dataset.provider = provider;  // Set the provider in the DOM
                const stopInfo = stopsData[stopId];
                
                console.log(`Processing stop ${stopId}:`, {
                    provider,
                    isDelijn,
                    hasData: !!stopInfo,
                    hasLines: stopInfo?.lines,
                    data: stopInfo
                });
                
                // Clear existing content but keep divider if it exists
                const divider = stopContainer.querySelector('.stop-divider');
                stopContainer.innerHTML = '';
                if (divider) {
                    stopContainer.appendChild(divider);
                }
                
                if (stopInfo && stopInfo.lines) {
                    for (const [line, destinations] of Object.entries(stopInfo.lines)) {
                        for (const [destination, times] of Object.entries(destinations)) {
                            if (!times || times.length === 0) continue;
                            
                            {# console.log(`Processing line ${line} to ${destination}:`, times); #}
                            
                            const lineContainer = document.createElement('div');
                            lineContainer.className = 'line-container';
                            
                            const lineColor = lineColors[line];
                            const style = isDelijn && typeof lineColor === 'object'
                                ? `
                                    --text-color: ${lineColor.text};
                                    --bg-color: ${lineColor.background};
                                    --text-border-color: ${lineColor.text_border};
                                    --bg-border-color: ${lineColor.background_border};
                                `
                                : `background-color: ${lineColor || '#666'}`;

                            // Process each passing time
                            const timeGroups = [];
                            for (let i = 0; i < times.length; i++) {
                                const time = times[i];
                                console.log('Processing time entry:', time);  // Debug log
                                
                                if (time.message) {
                                    timeGroups.push({
                                        message: time.message,
                                        is_message: true
                                    });
                                } else if (isDelijn) {
                                    // For De Lijn data, preserve all time information
                                    timeGroups.push({
                                        realtime_minutes: time.realtime_minutes,
                                        realtime_time: time.realtime_time,
                                        scheduled_minutes: time.scheduled_minutes,
                                        scheduled_time: time.scheduled_time,
                                        delay: time.delay,
                                        is_realtime: time.is_realtime,
                                        is_delijn: true
                                    });
                                } else {
                                    // For STIB data
                                    timeGroups.push({
                                        minutes: time.minutes,
                                        formatted_time: time.formatted_time,
                                        is_delijn: false
                                    });
                                }
                            }
                            
                            lineContainer.innerHTML = `
                                <div class="line-info">
                                    <span class="${isDelijn ? 'delijn-line-number' : 'line-number'}" 
                                          style="${style}">
                                        ${line}
                                    </span>
                                    <span class="direction">→ ${destination}</span>
                                </div>
                                <div class="times-container">
                                    ${timeGroups.map(group => {
                                        if (group.message) {
                                            return `<span class="service-message end-service">${group.message}</span>`;
                                        } else if (group.is_delijn) {
                                            // For De Lijn data
                                            if (group.is_realtime) {
                                                const delay = group.delay || 0;
                                                const delayClass = delay < 0 ? 'early' : delay > 0 ? 'late' : 'on-time';
                                                
                                                // Check if realtime and scheduled times are the same
                                                const sameTime = group.realtime_time === group.scheduled_time;
                                                
                                                return `
                                                    <span class="time-display delijn">
                                                        <span class="minutes ${delayClass}">${group.realtime_minutes}</span>
                                                        <span class="actual-time">
                                                            ${sameTime ? 
                                                                `(⚡/🕒 ${group.realtime_time})` : 
                                                                `(⚡${group.realtime_time} - 🕒${group.scheduled_time})`}
                                                        </span>
                                                    </span>
                                                `;
                                            } else {
                                                return `
                                                    <span class="time-display delijn">
                                                        <span class="minutes">${group.scheduled_minutes}</span>
                                                        <span class="actual-time">(🕒 ${group.scheduled_time})</span>
                                                    </span>
                                                `;
                                            }
                                        } else {

                                            const minutes = group.minutes;
                                            const time = group.formatted_time;
                                            
                                            if (minutes === undefined || !time) {
                                                console.debug('Missing time data:', group);
                                                return '';
                                            }

                                            return `
                                                <span class="time-display">
                                                    <span class="minutes ${parseInt(minutes) < 0 ? 'late' : ''}">${minutes}'</span>
                                                    <span class="actual-time"> (${time})</span>
                                                </span>
                                            `;
                                        }
                                    }).filter(Boolean).join('')}
                                </div>
                            `;
                            
                            stopContainer.appendChild(lineContainer);
                        }
                    }
                } else {
                    const noData = document.createElement('div');
                    noData.className = 'no-data';
                    noData.textContent = 'No real-time data available';
                    stopContainer.appendChild(noData);
                }
            });
        });
        
        // Then update map markers
        stopsLayer.eachLayer(marker => {
            const stopId = marker.stopId;
            const stopInfo = stopsData[stopId];
            const isDelijn = delijnConfig?.stops?.some(stop => stop.id === stopId);
            
            if (stopInfo && stopInfo.lines) {
                let popupContent = `<strong>${properTitle(stopInfo.name)}</strong><br>`;
                
                for (const [line, destinations] of Object.entries(stopInfo.lines)) {
                    for (const [destination, times] of Object.entries(destinations)) {
                        if (!times || times.length === 0) continue;
                        
                        const lineColor = lineColors[line];
                        const style = isDelijn && typeof lineColor === 'object'
                            ? `
                                --text-color: ${lineColor.text};
                                --bg-color: ${lineColor.background};
                                --text-border-color: ${lineColor.text_border};
                                --bg-border-color: ${lineColor.background_border};
                            `
                            : `background-color: ${lineColor || '#666'}`;
                        
                        // Add line and destination
                        popupContent += `
                            <div class="line-info">
                                <span class="${isDelijn ? 'delijn-line-number' : 'line-number'}" 
                                      style="${style}">
                                    ${line}
                                </span>
                                → ${destination}
                            </div>
                        `;
                        
                        // Add next arrival times (limit to 2 for popup)
                        const nextArrivals = times.slice(0, 2).map(time => {
                            if (isDelijn && time.is_realtime) {
                                const sameTime = time.realtime_time === time.scheduled_time;
                                const minutes = time.realtime_minutes !== undefined ? time.realtime_minutes : time.scheduled_minutes;
                                return sameTime ? 
                                    `${minutes} (⚡/🕒 ${time.realtime_time})` : 
                                    `${minutes} (⚡${time.realtime_time} - 🕒${time.scheduled_time})`;
                            } else {
                                const minutes = time.minutes !== undefined ? time.minutes : time.scheduled_minutes;
                                const displayTime = time.formatted_time || time.scheduled_time;
                                if (minutes === undefined || !displayTime) {
                                    console.debug('Missing time data in popup:', time);
                                    return '';
                                }
                                return `${minutes} (${displayTime})`;
                            }
                        }).filter(Boolean).join(', ');
                        
                        popupContent += `<div class="arrival-times">${nextArrivals}</div>`;
                    }
                }
                
                // Update popup content
                marker.setPopupContent(popupContent);
                
                // If popup is open, update it
                if (marker.isPopupOpen()) {
                    marker.getPopup().update();
                }
            }
        });
    }

    function updateServiceMessages(messages) {
        const primaryContainer = document.getElementById('primary-messages-container');
        const secondaryContainer = document.getElementById('secondary-messages-container');
        
        if (!messages || !messages.messages) {
            primaryContainer.innerHTML = '';
            secondaryContainer.innerHTML = '';
            return;
        }
        
        const primaryMessages = messages.messages.filter(m => m.is_monitored);
        const secondaryMessages = messages.messages.filter(m => !m.is_monitored);
        
        // Make this function async and await the renderMessages
        (async () => {
            // Update primary messages
            if (primaryMessages.length > 0) {
                primaryContainer.innerHTML = `
                    <div class="primary-messages">
                        <h2>Important Service Messages</h2>
                        ${await renderMessages(primaryMessages, false)}
                    </div>`;
            } else {
                primaryContainer.innerHTML = '';
            }
            
            // Update secondary messages
            if (secondaryMessages.length > 0) {
                secondaryContainer.innerHTML = `
                    <div class="secondary-messages">
                        <h2>Other Service Messages</h2>
                        ${await renderMessages(secondaryMessages, true)}
                    </div>`;
            } else {
                secondaryContainer.innerHTML = '';
            }
        })();
    }

    async function renderMessages(messages, isSecondary) {
        const messageElements = messages.map(message => {
            console.log('Message object:', message);

            const title = message.title || '';
            const text = message.text || message.description || '';
            const messageContent = title ? `<strong>${title}</strong><br>${text}` : text;

            // Get the lines array
            const lines = message.lines || message.affected_lines || [];
            
            // Render affected lines with proper styling
            const lineElements = lines.map(line => {
                // Check if this message has line_colors data
                if (message.line_colors && message.line_colors[line]) {
                    const colors = message.line_colors[line];
                    return `
                        <span class="delijn-line-number" style="
                            --text-color: ${colors.text};
                            --bg-color: ${colors.background};
                            --text-border-color: ${colors.text_border};
                            --bg-border-color: ${colors.background_border};
                        ">${line}</span>
                    `;
                } else {
                    // Default STIB styling
                    return `
                        <span class="line-number" style="background-color: ${lineColors[line] || '#666'}">
                            ${line}
                        </span>
                    `;
                }
            }).join('');

            // Rest of the message rendering...
            const stops = message.stops ? message.stops.join(', ') : 
                         message.affected_stops ? message.affected_stops.map(stop => stop.name).join(', ') : '';

            return `
                <div class="message ${isSecondary ? 'secondary' : ''}">
                    ${messageContent}
                    <div class="affected-details">
                        <div class="affected-lines">
                            Lines: ${lineElements}
                        </div>
                        ${stops ? `
                            <div class="affected-stops">
                                Stops: ${stops}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        });

        return messageElements.join('');
    }

    // Add a flag to track initial load
    let isInitialLoad = true;

    async function updateMapData(data) {
        // Only update vehicles, not routes and stops
        if (data.processed_vehicles) {
            const newVehiclePositions = new Set();
            
            data.processed_vehicles.forEach(vehicle => {
                // Handle both position formats
                const position = vehicle.interpolated_position || 
                               (vehicle.position ? [vehicle.position.lat, vehicle.position.lon] : null);
                
                if (!position) return;
                
                const [lat, lon] = position;
                const routeColor = lineColors[vehicle.line] || '#666';
                
                // Create a key for this vehicle based on line and direction
                const vehicleKey = `${vehicle.line}-${vehicle.direction}`;
                
                // Try to find an existing marker for this vehicle
                let existingMarker = null;
                let minDistance = Infinity;
                
                vehicleMarkers.forEach((marker, key) => {
                    // Only consider markers of the same line and direction
                    if (!key.startsWith(vehicleKey)) return;
                    
                    const markerPos = marker.getLatLng();
                    const distance = map.distance([lat, lon], [markerPos.lat, markerPos.lng]);
                    
                    // Consider it the same vehicle if it's within 500 meters
                    // (adjust this threshold based on your needs)
                    if (distance < 500 && distance < minDistance) {
                        existingMarker = marker;
                        minDistance = distance;
                    }
                });
                
                if (existingMarker) {
                    // Update existing marker
                    existingMarker.setLatLng([lat, lon]);
                    
                    // Update the icon's bearing
                    const isDelijn = delijnConfig?.monitored_lines?.includes(vehicle.line);
                    let markerStyle;
                    
                    if (isDelijn && typeof routeColor === 'object') {
                        markerStyle = `
                            --text-color: ${routeColor.text};
                            --bg-color: ${routeColor.background};
                            --text-border-color: ${routeColor.text_border};
                            --bg-border-color: ${routeColor.background_border};
                        `;
                    } else {
                        markerStyle = `--bg-color: ${routeColor}; --text-color: white;`;
                    }

                    const newIcon = L.divIcon({
                        html: `
                            <div class="vehicle-marker-content" style="
                                --bearing: ${vehicle.bearing}deg;
                                ${markerStyle}
                            ">
                                <div class="${isDelijn ? 'delijn-line-number' : 'line-number'}">
                                    ${vehicle.line}
                                </div>
                                <div class="vehicle-arrow"></div>
                            </div>
                        `,
                        className: 'vehicle-marker',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10],
                        popupAnchor: [0, -10]
                    });
                    existingMarker.setIcon(newIcon);
                    
                    const segmentInfo = getSegmentInfo(vehicle);
                    existingMarker.setPopupContent(`
                        <strong>Line ${vehicle.line}</strong><br>
                        Direction: ${vehicle.direction}<br>
                        ${segmentInfo}
                    `);
                    
                    // Mark this position as seen
                    newVehiclePositions.add(`${vehicleKey}-${lat}-${lon}`);
                } else {
                    // Create new marker as before
                    const marker = createVehicleMarker(vehicle, routeColor, lat, lon);
                    const markerKey = `${vehicleKey}-${lat}-${lon}`;
                    vehicleMarkers.set(markerKey, marker);
                    newVehiclePositions.add(markerKey);
                }
            });
            
            // Remove markers that are no longer present
            vehicleMarkers.forEach((marker, key) => {
                if (!newVehiclePositions.has(key)) {
                    marker.remove();
                    vehicleMarkers.delete(key);
                }
            });
        }
    }

    // Helper function to create a new vehicle marker
    function createVehicleMarker(vehicle, routeColor, lat, lon) {
        const isDelijn = delijnConfig?.monitored_lines?.includes(vehicle.line);
        let markerStyle;
        
        if (isDelijn && typeof routeColor === 'object') {
            markerStyle = `
                --text-color: ${routeColor.text};
                --bg-color: ${routeColor.background};
                --text-border-color: ${routeColor.text_border};
                --bg-border-color: ${routeColor.background_border};
            `;
        } else {
            markerStyle = `--bg-color: ${routeColor}; --text-color: white;`;
        }
        
        const vehicleIcon = L.divIcon({
            html: `
                <div class="vehicle-marker-content" style="
                    --bearing: ${vehicle.bearing}deg;
                    ${markerStyle}
                ">
                    <div class="${isDelijn ? 'delijn-line-number' : 'line-number'}">
                        ${vehicle.line}
                    </div>
                    <div class="vehicle-arrow"></div>
                </div>
            `,
            className: 'vehicle-marker',
            iconSize: [20, 20],
            iconAnchor: [10, 10],
            popupAnchor: [0, -10]
        });
        
        const marker = L.marker([lat, lon], {
            icon: vehicleIcon,
            pane: 'vehiclesPane',
            zIndexOffset: 1000
        });
        
        const segmentInfo = getSegmentInfo(vehicle);
        marker.bindPopup(`
            <strong>Line ${vehicle.line}</strong><br>
            Direction: ${vehicle.direction}<br>
            ${segmentInfo}
        `);
        
        marker.addTo(vehiclesLayer);
        return marker;
    }

    // Add this function to fetch coordinates for a stop
    async function fetchStopCoordinates(stopId) {
        try {
            // First try STIB coordinates
            const stibResponse = await fetch(`/api/stop_coordinates/${stopId}`);
            if (stibResponse.ok) {
                const data = await stibResponse.json();
                if (data.coordinates && data.coordinates.lat && data.coordinates.lon) {
                    return data.coordinates;
                }
            }

            // If not found in STIB, check if it's a De Lijn stop
            if (delijnConfig && delijnConfig.stops) {
                const delijnStop = delijnConfig.stops.find(stop => stop.id === stopId);
                if (delijnStop && delijnStop.coordinates) {
                    return delijnStop.coordinates;
                }
            }

            console.warn(`No coordinates found for stop ${stopId}`);
            return null;
        } catch (error) {
            console.error(`Error fetching coordinates for stop ${stopId}:`, error);
            return null;
        }
    }

    // Update the updateStopMarkerPopup function to handle De Lijn colors
    async function updateStopMarkerPopup(stopId, stopInfo) {
        stopsLayer.eachLayer(async (marker) => {
            if (marker.stopId === stopId) {
                let popupContent = `<strong>${properTitle(stopInfo.name)}</strong><br>`;
                
                if (stopInfo.lines) {
                    // Process all lines at once
                    const linePromises = Object.entries(stopInfo.lines).map(async ([line, destinations]) => {
                        const isDelijn = delijnConfig?.monitored_lines?.includes(line);
                        let style;
                        
                        if (isDelijn) {
                            const delijnColors = await getDeLijnColors(line);
                            if (delijnColors) {
                                style = `
                                    --text-color: ${delijnColors.text};
                                    --bg-color: ${delijnColors.background};
                                    --text-border-color: ${delijnColors.text_border};
                                    --bg-border-color: ${delijnColors.background_border};
                                `;
                            }
                        } else {
                            const lineColor = lineColors[line] || '#666';
                            style = `--bg-color: ${lineColor}; --text-color: white;`;
                        }

                        return `
                            <div class="line-info">
                                <span class="${isDelijn ? 'delijn-line-number' : 'line-number'}" 
                                      style="${style}">
                                    ${line}
                                </span>
                                → ${destinations.join(', ')}
                            </div>
                        `;
                    });
                    
                    // Wait for all line styles to be processed
                    const lineElements = await Promise.all(linePromises);
                    popupContent += lineElements.join('');
                }
                
                marker.setPopupContent(popupContent);
            }
        });
    }

    // Modify the initializeMapLayers function to store stopId with markers
    async function initializeMapLayers(data) {
        console.log("Initializing map layers with data:", data);
        
        // Add route shapes
        if (data.shapes) {
            for (const [line, shapeData] of Object.entries(data.shapes)) {
                console.log(`Processing shape for line ${line}:`, shapeData);
                
                // Handle STIB shapes (array format)
                if (Array.isArray(shapeData)) {
                    shapeData.forEach(variant => {
                        if (variant && variant.coordinates) {
                            const convertedCoords = variant.coordinates.map(coord => [coord[1], coord[0]]);
                            L.polyline(convertedCoords, {
                                color: lineColors[line] || '#666',
                                weight: 3,
                                opacity: 0.7,
                                pane: 'routesPane',
                                interactive: false
                            }).addTo(routesLayer);
                        }
                    });
                }
                // Handle De Lijn shapes (object format with variants)
                else if (shapeData.variants) {
                    shapeData.variants.forEach(variant => {
                        if (variant && variant.coordinates) {
                            const lineColor = typeof lineColors[line] === 'object' 
                                ? lineColors[line].background 
                                : lineColors[line] || '#666';
                                
                            L.polyline(variant.coordinates, {
                                color: lineColor,
                                weight: 3,
                                opacity: 0.7,
                                pane: 'routesPane',
                                interactive: false
                            }).addTo(routesLayer);
                        }
                    });
                }
            }
        }
        
        // Add stops
        if (data.display_stops) {
            for (const stop of data.display_stops) {
                const coordinates = await fetchStopCoordinates(stop.id);
                if (coordinates && coordinates.lat && coordinates.lon) {
                    const marker = L.circleMarker([coordinates.lat, coordinates.lon], {
                        radius: 8,
                        fillColor: '#fff',
                        color: '#000',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                        pane: 'stopsPane'
                    });
                    
                    // Store the stop ID with the marker
                    marker.stopId = stop.id;
                    
                    // Initial popup content
                    let popupContent = `<strong>${properTitle(stop.name)}</strong><br>`;
                    if (stop.lines) {
                        popupContent += Object.entries(stop.lines)
                            .map(([line, destinations]) => 
                                `<span class="line-number" style="background-color: ${lineColors[line] || '#666'}">${line}</span> → ${destinations.join(', ')}`
                            ).join('<br>');
                    }
                    
                    marker.bindPopup(popupContent);
                    marker.addTo(stopsLayer);
                } else {
                    console.warn(`Missing or invalid coordinates for stop ${stop.name} (${stop.id})`);
                }
            }
        }
    }

    // Add this function to calculate walking time
    function calculateWalkingTime(meters) {
        const seconds = meters / WALKING_SPEED;
        const minutes = Math.round(seconds / 60);
        return minutes;
    }

    // Add this function to format distance
    function formatDistance(meters) {
        if (meters < 1000) {
            return `${Math.round(meters)}m`;
        }
        return `${(meters / 1000).toFixed(1)}km`;
    }

    // Modify the updateDistances function
    function updateDistances(position) {
        if (!position || (!position.lat && !position.latitude)) {
            console.log('No valid position available');
            return;
        }
        
        // Normalize position format
        const lat = position.lat || position.latitude;
        const lng = position.lng || position.longitude;
        
        const stopsContainer = document.getElementById('stops-container');
        const stopSections = Array.from(stopsContainer.querySelectorAll('.stop-section'));
        const distanceInfo = document.getElementById('distance-info');
        
        // Create an array to store stop sections with their distances
        const stopsWithDistances = [];
        
        stopSections.forEach(section => {
            const stopId = section.querySelector('.physical-stop')?.dataset.stopId;
            if (!stopId) return;
            
            const h2 = section.querySelector('h2');
            
            // Find or create distance element
            let distanceElement = section.querySelector('.stop-distance');
            if (!distanceElement) {
                distanceElement = document.createElement('div');
                distanceElement.className = 'stop-distance';
                h2.appendChild(distanceElement);
            }
            
            // Find stop marker and calculate distance
            stopsLayer.eachLayer(marker => {
                if (marker.stopId === stopId) {
                    const markerPos = marker.getLatLng();
                    const distance = map.distance(
                        [lat, lng],
                        [markerPos.lat, markerPos.lng]
                    );
                    
                    const walkingTime = calculateWalkingTime(distance);
                    distanceElement.innerHTML = `
                        <span class="walking-time">🚶 ${walkingTime} min</span>
                        <span class="distance">(${formatDistance(distance)})</span>
                    `;
                    
                    stopsWithDistances.push({
                        element: section,
                        distance: distance
                    });
                }
            });
        });
        
        // Sort stops by distance
        stopsWithDistances.sort((a, b) => a.distance - b.distance);
        
        // Reorder the DOM elements
        stopsWithDistances.forEach(stop => {
            stopsContainer.appendChild(stop.element);
        });
        
        // Hide the loading popup after calculations are complete
        if (distanceInfo) {
            distanceInfo.classList.add('hidden');
            setTimeout(() => {
                distanceInfo.remove();
            }, 300);
        }
    }

    // Modify the document.addEventListener('DOMContentLoaded') to include geolocation
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            console.log("Starting initialization...");
            
            // First fetch De Lijn config
            const delijnConfigResponse = await fetch('/api/delijn/config');
            if (!delijnConfigResponse.ok) {
                throw new Error('Error fetching De Lijn configuration');
            }
            delijnConfig = await delijnConfigResponse.json();
            console.log('De Lijn config:', delijnConfig);

            // Populate DELIJN_STOP_IDS
            if (delijnConfig && delijnConfig.stops) {
                DELIJN_STOP_IDS = new Set(delijnConfig.stops.map(stop => stop.id));
            }

            // Add De Lijn stops to the page
            if (delijnConfig.stops && delijnConfig.stops.length > 0) {
                const stopsContainer = document.getElementById('stops-container');
                
                delijnConfig.stops.forEach(stop => {
                    const stopSection = document.createElement('div');
                    stopSection.className = 'stop-section';
                    stopSection.dataset.stopName = stop.name;
                    
                    stopSection.innerHTML = `
                        <h2>${properTitle(stop.name)}</h2>
                        <div class="stop-content">
                            <div class="physical-stop" data-stop-id="${stop.id}">
                                <div class="loading">Loading real-time data...</div>
                            </div>
                        </div>
                    `;
                    
                    stopsContainer.appendChild(stopSection);
                });
            }

            // Fetch STIB static data
            const stibStaticResponse = await fetch('/api/static_data');
            if (!stibStaticResponse.ok) {
                throw new Error('Error fetching STIB static data');
            }
            const stibStaticData = await stibStaticResponse.json();
            console.log('STIB static data:', stibStaticData);

            // Combine route colors
            lineColors = {
                ...stibStaticData.route_colors
            };

            // Fetch De Lijn routes and colors
            if (delijnConfig && delijnConfig.monitored_lines) {
                console.log("Fetching De Lijn routes and colors...");
                const [routes, colors] = await Promise.all([
                    fetchDeLijnRoutes(delijnConfig.monitored_lines),
                    Promise.all(delijnConfig.monitored_lines.map(async line => {
                        const response = await fetch(`/api/delijn/lines/${line}/colors`);
                        if (response.ok) {
                            const colorData = await response.json();
                            lineColors[line] = colorData;
                            return { line, colors: colorData };
                        }
                    }))
                ]);
                
                console.log("De Lijn routes:", routes);
                console.log("De Lijn colors:", colors);
                
                // Add routes to static data
                stibStaticData.shapes = {
                    ...stibStaticData.shapes,
                    ...routes
                };
            }

            // Initialize map with combined static data
            const combinedStaticData = {
                ...stibStaticData,
                display_stops: [
                    ...stibStaticData.display_stops,
                    ...(delijnConfig?.stops || [])
                ]
            };

            console.log("Initializing map with combined data:", combinedStaticData);
            await initializeMapLayers(combinedStaticData);

            // Handle any errors
            if (stibStaticData.errors?.length > 0) {
                updateErrors([], stibStaticData.errors);
            }

            // Start real-time updates
            console.log("Starting real-time updates...");
            fetchAndUpdateData();
            setInterval(fetchAndUpdateData, REFRESH_INTERVAL);

            // Add geolocation handling
            if ('geolocation' in navigator && isSecure) {
                const distanceInfo = document.getElementById('distance-info');
                distanceInfo.innerHTML = 'Requesting location access...';
                
                // Initial position request
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        lastLocationUpdate = Date.now();
                        updateDistances(userLocation);
                        
                        // Set up periodic location updates
                        locationWatchId = navigator.geolocation.watchPosition(
                            (newPosition) => {
                                // Only update if enough time has passed
                                if (Date.now() - lastLocationUpdate >= LOCATION_UPDATE_INTERVAL) {
                                    userLocation = {
                                        lat: newPosition.coords.latitude,
                                        lng: newPosition.coords.longitude
                                    };
                                    lastLocationUpdate = Date.now();
                                    updateDistances(userLocation);
                                }
                            },
                            null,
                            { 
                                enableHighAccuracy: true, // Better data is always better
                                maximumAge: LOCATION_UPDATE_INTERVAL,
                                timeout: 10000
                            }
                        );
                    },
                    (error) => {
                        console.log('Geolocation error:', error);
                        useMapCenter();
                    }
                );
            } else {
                console.log('Geolocation not available or not in secure context');
                useMapCenter();
            }

            // Add this function to handle map center updates
            function useMapCenter() {
                userLocation = map.getCenter();
                updateDistances(userLocation);
                
                // Update distances when map is moved
                map.on('moveend', () => {
                    userLocation = map.getCenter();
                    updateDistances(userLocation);
                });
            }

            // Clean up location watch when page is hidden/closed
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && locationWatchId !== null) {
                    navigator.geolocation.clearWatch(locationWatchId);
                    locationWatchId = null;
                } else if (!document.hidden && !locationWatchId && 'geolocation' in navigator) {
                    // Restart watching when page becomes visible again
                    navigator.geolocation.getCurrentPosition(position => {
                        userLocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        lastLocationUpdate = Date.now();
                        updateDistances(userLocation);
                        
                        locationWatchId = navigator.geolocation.watchPosition(
                            // ... same watch options as above ...
                        );
                    });
                }
            });

        } catch (error) {
            console.error('Error loading static data:', error);
            const errorsContainer = document.getElementById('errors-container');
            if (errorsContainer) {
                errorsContainer.innerHTML = `
                    <div class="error-section">
                        <div class="error-message">
                            Error loading map data: ${error.message}
                        </div>
                    </div>
                `;
            }
        }
    });

    function properTitle(text) {
        // Handle undefined, null, or non-string input
        if (!text) {
            return '';
        }
        
        // Convert to string if it isn't already
        text = String(text);
        
        // List of words that should remain uppercase
        const uppercaseWords = new Set(['uz', 'vub', 'ulb']);
        
        // Split on spaces and hyphens
        const words = text.toLowerCase().replace('-', ' - ').split(' ');
        
        // Process each word
        return words.map(word => {
            // Skip empty words
            if (!word) return '';
            
            // Handle words with periods (abbreviations)
            if (word.includes('.')) {
                const parts = word.split('.');
                return parts.map(p => 
                    p && uppercaseWords.has(p.toLowerCase()) ? 
                        p.toUpperCase() : 
                        p ? p.charAt(0).toUpperCase() + p.slice(1).toLowerCase() : ''
                ).join('.');
            } else if (uppercaseWords.has(word)) {
                return word.toUpperCase();
            } else {
                return word.charAt(0).toUpperCase() + word.slice(1);
            }
        }).filter(Boolean).join(' ') || 'Unknown';  // Return 'Unknown' if result is empty
    }

    // Add error handling function
    function updateErrors(errors, shapeErrors) {
        const errorsContainer = document.getElementById('errors-container');
        if (!errorsContainer) {
            console.warn('Errors container not found');
            return;
        }

        let html = '';
        
        if (errors && errors.length > 0) {
            html += '<div class="error-section"><h2>Errors</h2>';
            errors.forEach(error => {
                html += `<div class="error-message">${error}</div>`;
            });
            html += '</div>';
        }
        
        if (shapeErrors && shapeErrors.length > 0) {
            html += '<div class="error-section"><h3>Shape Data Errors</h3>';
            shapeErrors.forEach(error => {
                html += `<div class="error-message secondary">${error}</div>`;
            });
            html += '</div>';
        }
        
        errorsContainer.innerHTML = html;
    }

    // Add this function to fetch stop names
    async function fetchStopNames(stopIds) {
        try {
            const response = await fetch('/api/stop_names', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(stopIds)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            if (data && data.stops) {
                stopNames = {...stopNames, ...data.stops};
            }
        } catch (error) {
            console.error('Error fetching stop names:', error);
        }
    }

    // Update the vehicle marker creation/update code to handle missing stop names
    function getSegmentInfo(vehicle) {
        let segmentInfo = '';
        if (vehicle.current_segment && vehicle.current_segment.length === 2) {
            const [currentStopId, nextStopId] = vehicle.current_segment;
            const currentStop = stopNames[currentStopId]?.name || currentStopId;
            const nextStop = stopNames[nextStopId]?.name || nextStopId;
            segmentInfo = `Between ${properTitle(currentStop)} and ${properTitle(nextStop)}`;
            
            // Fetch missing stop names if needed
            const missingStops = [];
            if (!stopNames[currentStopId]) missingStops.push(currentStopId);
            if (!stopNames[nextStopId]) missingStops.push(nextStopId);
            if (missingStops.length > 0) {
                fetchStopNames(missingStops);
            }
        }
        return segmentInfo;
    }

    // Add function to fetch De Lijn colors for a line
    async function getDeLijnColors(line) {
        const isDelijnLine = delijnConfig?.monitored_lines?.includes(line);
        if (!isDelijnLine) {
            return null;
        }

        try {
            if (lineColors[line] && typeof lineColors[line] === 'object') {
                return lineColors[line];
            }

            const response = await fetch(`/api/delijn/lines/${line}/colors`);
            if (response.ok) {
                const colors = await response.json();
                lineColors[line] = colors;
                return colors;
            }
        } catch (e) {
            console.error(`Error fetching colors for line ${line}:`, e);
        }
        return null;
    }

    // Add this function
    function resetMapView() {
        map.setView(
            [map_config.center.lat, map_config.center.lon], 
            map_config.zoom
        );
        if (!userLocation) {
            // If we're using map center for distances, update them
            userLocation = map.getCenter();
            updateDistances(userLocation);
        }
    }
    </script>
</head>
<body>
    <h1>Next Buses</h1>
    <div id="map"></div>
    <div class="map-controls">
        <a onclick="resetMapView()">Reset map view</a>
    </div>
    <div id="distance-info" class="distance-info loading">
        Calculating distances...
    </div>
    <div id="errors-container"></div>
    <div id="primary-messages-container"></div>
    <div id="stops-container">
        <!-- Initial loading state - grouped by name -->
        {% set grouped_stops = {} %}
        {% for stop in stops %}
            {% if stop.id in DELIJN_STOP_IDS %}
                {% set provider = 'delijn' %}
            {% else %}
                {% set provider = 'stib' %}
            {% endif %}
            {% set _ = grouped_stops.setdefault(stop.name, {'stops': [], 'provider': provider}).stops.append(stop) %}
        {% endfor %}
        
        {% for stop_name, group in grouped_stops.items() %}
        <div class="stop-section" data-stop-name="{{ stop_name }}">
            <h2>{{ stop_name|proper_title }}</h2>
            <div class="stop-content">
                {% for stop in group.stops %}
                    <div class="physical-stop" 
                         data-stop-id="{{ stop.id }}"
                         data-provider="{{ 'delijn' if stop.id in DELIJN_STOP_IDS else 'stib' }}">
                        {% if not loop.first %}
                            <div class="stop-divider"></div>
                        {% endif %}
                        <div class="loading">Loading real-time data...</div>
                    </div>
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>
    <div id="secondary-messages-container"></div>
    
    <!-- Initialize map -->
    <script>
        // Initialize map
        map = L.map('map', {
            center: [
                map_config.center.lat, 
                map_config.center.lon
            ],
            zoom: map_config.zoom,
            zoomControl: true,
            layers: []
        });
        
        // Add the tile layer first
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            minZoom: 11,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);
        
        // Create custom panes BEFORE creating the layers
        map.createPane('routesPane');
        map.createPane('stopsPane');
        map.createPane('vehiclesPane');
        
        // Set z-index for panes
        map.getPane('routesPane').style.zIndex = 400;
        map.getPane('stopsPane').style.zIndex = 450;
        map.getPane('vehiclesPane').style.zIndex = 500;
        
        // Now create the feature groups with their specific panes
        routesLayer = L.featureGroup([], {
            pane: 'routesPane'
        }).addTo(map);
        
        stopsLayer = L.featureGroup([], {
            pane: 'stopsPane'
        }).addTo(map);
        
        vehiclesLayer = L.featureGroup([], {
            pane: 'vehiclesPane'
        }).addTo(map);
        
        // Add layer control
        const overlays = {
            "Routes": routesLayer,
            "Stops": stopsLayer,
            "Vehicles": vehiclesLayer
        };
        L.control.layers(null, overlays).addTo(map);
        
        // Initial fetch
        fetchAndUpdateData();
        
        // Update every 60 seconds
        setInterval(fetchAndUpdateData, REFRESH_INTERVAL);
    </script>
</body>
</html>